/*
 * ProvincePanel.java
 *
 * Created on January 14, 2008, 4:02 PM
 */

package eu2posed;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;

/**
 *
 * @author  Michael
 */
public class ProvincePanel extends javax.swing.JPanel {
    
    private ProvinceData.Province province;
    private IDMapPanel.ProvinceImage image;
    private BufferedImage scaledImage;
    
    // the coordinates in the overall map of the upper-left corner of the image
    private double xPos;
    private double yPos;
    
    // how far it's zoomed in
    private double scale;
    
    // how much this province image is scaled to make it big enough
    // total scale = scale * ourScale
    private static final double ourScale = 1.0;
    
    // where in the panel the image will be drawn (hopefully so that it's centered)
    private int imageOrigin;
    
    private static final Color CITY_COLOR = Color.BLUE;
    private static final Color PORT_COLOR = Color.GREEN;
    private static final Color ARMY_COLOR = Color.RED;
    private static final Color MANU_COLOR = Color.BLACK;
    private static final Color TERRAIN_COLOR = Color.YELLOW;
    
    private Color textColor;
    private boolean drawGridLines = true;
    private int gridSize = 10;
    
    /** Creates new form ProvincePanel */
    public ProvincePanel() {
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
    private static final RenderingHints drawingHints = new RenderingHints(null);
    static {
        drawingHints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        drawingHints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        drawingHints.put(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);
        drawingHints.put(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
        drawingHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        drawingHints.put(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);
        drawingHints.put(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);
    }
    
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        
        if (image != null) {
            Graphics2D g2d = (Graphics2D)g;
            
            g2d.addRenderingHints(drawingHints);
            
            g2d.drawImage(scaledImage, (getWidth() - scaledImage.getWidth())/2, 0, null);
            
//            Font oldFont = g2d.getFont();
//            g2d.setFont(oldFont.deriveFont(Font.BOLD, (float)ourScale));
            
            Paint oldPaint = g2d.getPaint();
            g2d.setColor(textColor);
            
            // draw icons
            if (province != null) {
//                int id = image.getProvId();
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.CITY), g2d, "City", CITY_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.ARMY), g2d, "Army", ARMY_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.PORT), g2d, "Port", PORT_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.MANU), g2d, "Manufactory", MANU_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.TERRAIN_1), g2d, "Terrain 1 (" + province.getTerrainVariant(ProvinceData.TerrainVariantType.TERRAIN_1_TYPE) + ")", TERRAIN_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.TERRAIN_2), g2d, "Terrain 2 (" + province.getTerrainVariant(ProvinceData.TerrainVariantType.TERRAIN_2_TYPE) + ")", TERRAIN_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.TERRAIN_3), g2d, "Terrain 3 (" + province.getTerrainVariant(ProvinceData.TerrainVariantType.TERRAIN_3_TYPE) + ")", TERRAIN_COLOR);
                drawPointIfPossible(province.getSpritePos(ProvinceData.GfxType.TERRAIN_4), g2d, "Terrain 4 (" + province.getTerrainVariant(ProvinceData.TerrainVariantType.TERRAIN_4_TYPE) + ")", TERRAIN_COLOR);
            }
            
            if (drawGridLines)
                drawGridLines(g2d);
            
            g2d.setPaint(oldPaint);
//            g2d.setFont(oldFont);
        }
    }
    
    @Override
    public Dimension getPreferredSize() {
        if (image != null)
            return new Dimension(scaledImage.getWidth(), scaledImage.getHeight());
        return super.getPreferredSize();
    }
    
    private void drawPointIfPossible(Point p, Graphics2D g, String text, Color color) {
        if (p != null) {
            float x = translateX(p.x);
            float y = translateY(p.y);
            
            // draw 7-pixel circle centered on the point
            Paint old = g.getPaint();
            g.setColor(color);
            g.fillOval((int) x-3, (int) y-3, 7, 7);
            g.setPaint(old);
            
            // move text slightly up and right to make room for the circle
            g.drawString(text, x+3, y-3);
        }
    }
    
    private static final double EPSILON = 0.0001;
    private void drawGridLines(Graphics2D g) {
//        int width = (int) (getWidth() * ourScale);
//        int height = (int) (getHeight() * ourScale);
        double increment = (gridSize*ourScale);
        
        int startX = image.getImageBounds().x;
        while (true) {
            double tmp2 = Math.abs(Math.IEEEremainder((double) startX, 10.0));
            if (tmp2 < EPSILON || (10-tmp2) < EPSILON) {
//                System.out.println("Starting x is " + startX);
//                System.out.println("Remainder was " + tmp2);
                startX = (int) translateX(startX);
                break;
            }
            startX++;
        }
        int startY = image.getImageBounds().y;
        while (true) {
            double tmp2 = Math.abs(Math.IEEEremainder((double) startY, 10.0));
            if (tmp2 < EPSILON || (10-tmp2) < EPSILON) {
//                System.out.println("Starting y is " + startY);
//                System.out.println("Remainder was " + tmp2);
                startY = (int) translateY(startY);
                break;
            }
            startY++;
        }
        
        
        final int x = (int) ((getWidth() - scaledImage.getWidth())/2.0);
        final int endX = x + scaledImage.getWidth();
        final int endY = scaledImage.getHeight();
        
        for (int i = startX; i < endX; i = (int) (i+increment)) {
//            System.out.println(i + "->" + reverseTranslateX(i));
            g.drawLine(i, 0, i, endY);
        }
        for (int i = startY; i < endY; i = (int) (i+increment)) {
            g.drawLine(x, i, endX, i);
        }
    }
    
    public float translateX(double coordinate) {
        // scale and add
        // x_new = (x*scale - xPos)*ourScale + imageOrigin
        coordinate *= scale;
        coordinate -= xPos;
        coordinate *= ourScale;
        
        coordinate += (getWidth() - scaledImage.getWidth())/2.0;
        
//        System.out.println("x: " + coordinate);
        return (float) coordinate;
    }
    
    public double reverseTranslateX(double coordinate) {
        coordinate -= (getWidth() - scaledImage.getWidth())/2.0;
        
        coordinate /= ourScale;
        coordinate += xPos;
        coordinate /= scale;
        
        return coordinate;
    }
    
    public float translateY(double coordinate) {
        // flip, scale, and add
        // y_new = (mapHeight - (y*scale + yPos))*ourScale
        coordinate *= scale;
        coordinate -= yPos;
//        coordinate = image.getMapHeight() - coordinate;
        coordinate *= ourScale;
        
//        System.out.println("y: " + coordinate);
        return (float) coordinate;
    }
    
    
    public double reverseTranslateY(double coordinate) {
        coordinate /= ourScale;
//        coordinate = image.getMapHeight() - coordinate;
        coordinate += yPos;
        coordinate /= scale;
        
        return coordinate;
    }

    public IDMapPanel.ProvinceImage getImage() {
        return image;
    }

    public void setImage(IDMapPanel.ProvinceImage image) {
        this.image = image;
        this.xPos = image.getImageBounds().x;
        this.yPos = image.getImageBounds().y;
        this.scale = image.getScale();
        
//        this.ourScale = Math.min(2.0, 600 / image.getImageBounds().getHeight());    // try to get a height of 600
//        this.ourScale = Math.max(ourScale, 0.5);
//        this.ourScale = Math.round(ourScale);
        this.scaledImage = createScaledImage(image.getImage(), ourScale);
        
        this.imageOrigin = (getWidth() - scaledImage.getWidth())/2;
    }
    
    private static final RenderingHints scalingHints = new RenderingHints(null);
    static {
        scalingHints.put(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
//        scalingHints.put(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_DISABLE);
        scalingHints.put(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);
        scalingHints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    }
    
    private static BufferedImage createScaledImage(BufferedImage original, double scale) {
        final BufferedImageOp scaleOp =
                new AffineTransformOp(
                new AffineTransform(scale, 0.0, 0.0, scale, 0.0, 0.0),
                scalingHints
                );
        
        final BufferedImage ret = new BufferedImage(
                (int) Math.round(original.getWidth() * scale),
                (int) Math.round(original.getHeight() * scale),
                original.getType());
        
        Graphics2D g = ret.createGraphics();
        g.drawImage(original, scaleOp, 0, 0);
        g.dispose();
        
        return ret;
    }

    public ProvinceData.Province getProvince() {
        return province;
    }

    public void setProvince(ProvinceData.Province province) {
        this.province = province;
    }

    public boolean isDrawGridLines() {
        return drawGridLines;
    }

    public void setDrawGridLines(boolean drawGridLines) {
        this.drawGridLines = drawGridLines;
    }
}
