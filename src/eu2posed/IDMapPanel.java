/*
 * IDMapPanel.java
 *
 * Created on January 12, 2008, 3:38 PM
 */

package eu2posed;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.geom.AffineTransform;
import java.awt.image.AffineTransformOp;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.util.Locale;

/**
 *
 * @author Michael Myers
 */
public class IDMapPanel extends javax.swing.JPanel {
    
    private IdTbl id;
    private BoundboxTbl bounds;
    private BufferedImage image;
    private BufferedImage scaledImage;
    private double scaleFactor = 0.1;
    private static final double DEFAULT_ZOOM_AMOUNT = 0.025;
    private static final double MIN_SCALE = 0.001;
    private static final double MAX_SCALE = 2.0;
    
    private static final boolean paintPositions = true;
    
    public IDMapPanel() {
        initComponents();
    }
    
    public IDMapPanel(IdTbl id) {
        setIdTbl(id);
        initComponents();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
    }// </editor-fold>//GEN-END:initComponents
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
    
    private static final RenderingHints scalingHints = new RenderingHints(null);
    static {
        // looking for something that keeps thin black lines from disappearing entirely when scaled down
        
        scalingHints.put(RenderingHints.KEY_INTERPOLATION,  RenderingHints.VALUE_INTERPOLATION_BICUBIC); //NEAREST_NEIGHBOR);
//        scalingHints.put(RenderingHints.KEY_DITHERING,      RenderingHints.VALUE_DITHER_DISABLE);
//        scalingHints.put(RenderingHints.KEY_COLOR_RENDERING,RenderingHints.VALUE_COLOR_RENDER_QUALITY);
        scalingHints.put(RenderingHints.KEY_RENDERING,      RenderingHints.VALUE_RENDER_QUALITY);
    }
    
    private void rescaleMap() {
        if (scaledImage != null) {
            scaledImage.flush();
            scaledImage = null;
        }
        
        final BufferedImageOp scaleOp =
                new AffineTransformOp(
                new AffineTransform(scaleFactor, 0.0, 0.0, scaleFactor, 0.0, 0.0),
                scalingHints
                );
        
        scaledImage = new BufferedImage(
                (int) Math.ceil(image.getWidth() * scaleFactor),
                (int) Math.ceil(image.getHeight() * scaleFactor),
                image.getType()
                );
        
        final Graphics2D g = scaledImage.createGraphics();
        g.drawImage(image, scaleOp, 0, 0);
        g.dispose();
    }
            
    @Override
    protected void paintComponent(Graphics g) {
        if (scaledImage != null) {
            ((Graphics2D)g).drawImage(scaledImage, 0, 0, null);
            if (paintPositions)
                paintPositions((Graphics2D)g);
        }
    }
    
    private void paintPositions(final Graphics2D g) {
        for (int i = 1; i < ProvinceData.NUM_PROVINCES; i++) {
            ProvinceData.Province prov = id.getProvinceData().getProvince(i);
            if (prov != null) {
                translateAndPaint(g, prov.getSpritePos(ProvinceData.GfxType.CITY), Color.BLUE);
                translateAndPaint(g, prov.getSpritePos(ProvinceData.GfxType.ARMY), Color.RED);
                translateAndPaint(g, prov.getSpritePos(ProvinceData.GfxType.PORT), Color.GREEN);
                translateAndPaint(g, prov.getSpritePos(ProvinceData.GfxType.MANU), Color.BLACK);
            }
        }
    }
    
    private final void translateAndPaint(final Graphics2D g, final Point p, final Color c) {
        if (p != null) {
            paintPoint(g, (int) (p.x * scaleFactor), (int) (p.y * scaleFactor), c);
        }
    }
    
    private final void paintPoint(final Graphics2D g, int x, int y, Color color) {
        final Color old = g.getColor();
        g.setColor(color);
        if (scaleFactor < 0.25)
            g.fillOval(x-1, y-1, 3, 3);
        else if (scaleFactor < 0.5)
            g.fillOval(x-2, y-2, 5, 5);
        else if (scaleFactor < 1)
            g.fillOval(x-3, y-3, 7, 7);
        else
            g.fillOval(x-4, y-4, 9, 9);
//        g.drawLine(x, y, x, y);
        g.setColor(old);
    }

    @Override
    public Dimension getPreferredSize() {
        if (scaledImage != null) {
//            System.out.println("scaled image: width=" + scaledImage.getWidth() + ", height=" + scaledImage.getHeight());
            return new Dimension(scaledImage.getWidth(), scaledImage.getHeight());
        }
//        System.out.println("no scaled image");
        return super.getPreferredSize();
    }
    
    // Locale.US is necessary because, in some locales, the comma ',' is used as
    // the decimal separator, which Double.parseDouble doesn't recognize.
    private static final java.text.NumberFormat rounder = java.text.NumberFormat.getNumberInstance(Locale.US);
    static {
        if (rounder instanceof java.text.DecimalFormat) {
            ((java.text.DecimalFormat)rounder).setDecimalSeparatorAlwaysShown(true);
            ((java.text.DecimalFormat)rounder).setMaximumFractionDigits(3);
        }
    }

    public double getScaleFactor() {
        return scaleFactor;
    }

    public void setScaleFactor(double scaleFactor) {
        this.scaleFactor = scaleFactor;
    }
    
    public void zoomIn() {
        zoomIn(DEFAULT_ZOOM_AMOUNT);
    }
    
    public void zoomIn(double amount) {
        if (scaleFactor <= MAX_SCALE - amount) {
            scaleFactor += amount;
            scaleFactor = Double.parseDouble(rounder.format(scaleFactor));
            rescaleMap();
        }
    }
    
    public void zoomOut() {
        zoomOut(DEFAULT_ZOOM_AMOUNT);
    }
    
    public void zoomOut(double amount) {
        if (scaleFactor >= amount + MIN_SCALE) {
            scaleFactor -= amount;
            scaleFactor = Double.parseDouble(rounder.format(scaleFactor));
            rescaleMap();
        }
    }

    public IdTbl getIdTbl() {
        return id;
    }

    public final void setIdTbl(IdTbl id) {
        this.id = id;
        image = id.getImage();
        rescaleMap();
    }
    
    public BoundboxTbl getBoundbox() {
        return bounds;
    }

    public void setBoundbox(BoundboxTbl bounds) {
        this.bounds = bounds;
    }
    
    public ProvinceData.Province getProvince(int provid) {
        return id.getProvinceData().getProvince(provid);
    }
    
    public int getProvId(int x, int y) {
        return id.getId((int) (x/scaleFactor), (int) (y/scaleFactor));
    } 
    
    public ProvinceImage createImage(int provId) {
        Rectangle provBounds = bounds.getBounds(provId);
        
        Rectangle imgBounds = provBounds.getBounds();
        
        // expand the box a little
        imgBounds.x = Math.max(0, imgBounds.x-50);
        imgBounds.y = Math.max(0, imgBounds.y-50);
        imgBounds.width = Math.min(image.getWidth()-imgBounds.x, imgBounds.width + 100);
        imgBounds.height = Math.min(image.getHeight()-imgBounds.y, imgBounds.height + 100);

        try {
            BufferedImage img = image.getSubimage(imgBounds.x, imgBounds.y, imgBounds.width, imgBounds.height);
            return new ProvinceImage(img, provBounds, imgBounds, provId, id.getProvinceData().getName(provId), 1.0, image.getHeight());
        } catch (java.awt.image.RasterFormatException ex) {
            System.err.println("province bounds are " + provBounds);
            System.err.println("rectangle is " + imgBounds);
            System.err.println("scaled image's size is " + scaledImage.getWidth() + " x " + scaledImage.getHeight());
//            System.err.println("lines are: ");
//            for (Integer[] line : mapData.getLinesInProv(p.getColor())) {
//                System.err.println(java.util.Arrays.toString(line));
//            }
            throw ex;
        }
    }
    
    public static final class ProvinceImage {
        private BufferedImage image;
        private Rectangle provBounds;
        private Rectangle imgBounds;
        private int provId;
        private String provName;
        private double scale;
        private double mapHeight;

        public ProvinceImage(BufferedImage image, Rectangle provBounds, Rectangle imgBounds, int provId, String provName, double scale, int mapHeight) {
            this.image = image;
            this.provBounds = provBounds;
            this.imgBounds = imgBounds;
            this.provId = provId;
            this.provName = provName;
            this.scale = scale;
            this.mapHeight = mapHeight;
        }

        public BufferedImage getImage() {
            return image;
        }

        public Rectangle getProvBounds() {
            return provBounds;
        }
        
        public Rectangle getImageBounds() {
            return imgBounds;
        }

        public int getProvId() {
            return provId;
        }
        
        public String getProvName() {
            return provName;
        }
        
        public double getScale() {
            return scale;
        }
        
        public double getMapHeight() {
            return mapHeight;
        }
    }
}
